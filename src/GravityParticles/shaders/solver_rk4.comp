#version 430

#pragma optimize(on)

layout(local_size_x = {LocalSizeX}) in;

struct ComputeShaderConfig {
    int massCount;
    int particleCount;
    int mode;
    int colors;
    int markersVisible;
    int steps;
    float dt;
    float constantG;
    float sigma2;
    float clampVel;
    float clampAcc;
    vec2 initPos;
    vec2 initVel;
    float initR;
    float initVR;
    int plot;
    int plotWidth;
    int plotHeight;
    float plotZoom;
    vec2 plotOrigin;
    float mass[16];
    float position_x[16];
    float position_y[16];
};


struct Particle
{
    vec2 position;
    vec2 velocity;
	vec2 prev_pos;
	vec2 prev_vel;
	vec2 prevprev_pos;
	vec2 prevprev_vel;
    float mass;
    float _pad0;
    vec4 color;
};

// input buffer - only configuration
layout(std430, binding = 0) buffer ConfigBuffer {
    ComputeShaderConfig config;
};

// buffer containing point positions
layout(std430, binding = 1) buffer OutputBuffer {
    Particle points[];
};

layout(r32ui, binding = 2) uniform uimage2D plotImage;

const float M_PI        = 3.14159265358979323846;
const float CONSTANT_G  = 0.1;


float fast_atan2(float y, float x)
{
    float ax = abs(x);
    float ay = abs(y);

    float m = min(ax, ay) / max(ax, ay);
    float s = m * m;

    float a = (((-0.04649647 * s + 0.15931422) * s - 0.32762277) * s * m + m);

    a = (ay > ax) ? (1.57079637 - a) : a;
    a = (x < 0.0) ? (3.14159274 - a) : a;

    return a * sign(y);
}

vec3 hue_to_rgb(float h)
{
    vec3 c = vec3(h, 1.0, 1.0);
    vec3 rgb = clamp(
        abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,
        0.0,
        1.0
    );

    return c.z * mix(vec3(1.0), rgb, c.y);
}

void add_point_to_plot(vec2 pos, uint val)
{
    vec2 p = (pos - config.plotOrigin) * config.plotZoom;

    ivec2 px = ivec2(
        int(p.x) + imageSize(plotImage).x / 2,
        int(p.y) + imageSize(plotImage).y / 2
    );

    ivec2 size = imageSize(plotImage);

    if (px.x < 0 || px.y < 0 ||
        px.x >= size.x || px.y >= size.y)
    {
        return;
    }
    imageAtomicAdd(plotImage, px, val);
}


void update_plot(uint idx)
{
    Particle p = points[idx];
    if (config.plot == 1) {
        if ((p.position.x < 0 && p.prev_pos.x >= 0) || (p.position.x > 0 && p.prev_pos.x <= 0))
            add_point_to_plot(vec2(p.velocity.y / config.dt, p.position.y), 1);
    } else if (config.plot == 2) {
        if ((p.velocity.x < 0 && p.prev_vel.x >= 0) || (p.velocity.x > 0 && p.prev_vel.x <= 0))
            add_point_to_plot(vec2(p.velocity.y / config.dt, p.position.y), 1);
    } else if (config.plot == 3) {
        if ((p.prev_vel.x > p.velocity.x && p.prev_vel.x > p.prevprev_vel.x))
            add_point_to_plot(p.position * 0.5, 1);
    } else if (config.plot == 4) {
        if ((p.prev_vel.x > p.velocity.x && p.prev_vel.x > p.prevprev_vel.x))
            add_point_to_plot(vec2(p.velocity.y / config.dt, p.position.y), 1);
    }
}

vec2 compute_acceleration(vec2 position)
{
    vec2 acc = vec2(0.0);

    for (int i = 0; i < config.massCount; i++)
    {
        vec2 mass = vec2(config.position_x[i], config.position_y[i]);
        vec2 d = mass - position;
        float r2 = dot(d, d) + config.sigma2;
        float invR = inversesqrt(r2);
        float invR3 = invR * invR * invR;
        acc += d * invR3;
    }

    acc *= CONSTANT_G;
    return acc;
}

void update_one(uint idx)
{
    if (config.plot > 0) {
        points[idx].prevprev_pos = points[idx].prev_pos;
        points[idx].prevprev_vel = points[idx].prev_vel;
        points[idx].prev_pos = points[idx].position;
        points[idx].prev_vel = points[idx].velocity;
    }

    Particle p = points[idx];

    vec2 x = p.position;
    vec2 v = p.velocity;

    float dt = config.dt;
    float half_dt = 0.5 * dt;

    // ---- k1 ----
    vec2 k1_x = v;
    vec2 k1_v = compute_acceleration(x);

    // ---- k2 ----
    vec2 k2_x = v + half_dt * k1_v;
    vec2 k2_v = compute_acceleration(x + half_dt * k1_x);

    // ---- k3 ----
    vec2 k3_x = v + half_dt * k2_v;
    vec2 k3_v = compute_acceleration(x + half_dt * k2_x);

    // ---- k4 ----
    vec2 k4_x = v + dt * k3_v;
    vec2 k4_v = compute_acceleration(x + dt * k3_x);

    // ---- Final update ----
    vec2 new_x = x + (dt / 6.0) *
        (k1_x + 2.0*k2_x + 2.0*k3_x + k4_x);

    vec2 new_v = v + (dt / 6.0) *
        (k1_v + 2.0*k2_v + 2.0*k3_v + k4_v);

    points[idx].position = new_x;
    points[idx].velocity = new_v;

    if (config.plot > 0)
        update_plot(idx);
}

void add_color(uint idx)
{
    if (config.colors == 0) {
        points[idx].color.rgb = vec3(0.5, 0.5, 0.5);
    } else {
        float angle = atan(points[idx].velocity.y, points[idx].velocity.x);
        float h = (angle + M_PI) / (2 * M_PI);
        points[idx].color.rgb = hue_to_rgb(h);
    }
}

float rand(uint seed)
{
    seed ^= seed >> 17;
    seed *= 0xed5ad4bbU;
    seed ^= seed >> 11;
    seed *= 0xac4c1b51U;
    seed ^= seed >> 15;
    seed *= 0x31848babU;
    seed ^= seed >> 14;
    return float(seed) * (1.0 / 4294967296.0);
}

void init_randomly(uint idx)
{
    uint seed = idx << 2;
    float r = config.initR * (rand(seed)-0.5);
    float angle = rand(seed+1) * 2 * M_PI;
    points[idx].position.x = config.initPos.x + r * sin(angle);
    points[idx].position.y = config.initPos.y + r * cos(angle);

    r = config.initVR * (rand(seed+2)-0.5);
    angle = rand(seed+3) * 2 * M_PI;
    points[idx].velocity.x = config.initVel.x + r * sin(angle);
    points[idx].velocity.y = config.initVel.y + r * cos(angle);
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;

    if (idx >=0 && idx < config.particleCount) {

        if (config.mode == 0) {

            update_one(idx);
            add_color(idx);

        } else if (config.mode == 1) {

            init_randomly(idx);
            for(int s=0; s<config.steps; s++) { 
                update_one(idx);
            }

            add_color(idx);
        }

    } else if (idx < config.particleCount + config.massCount) {
        uint coeffIdx = idx - config.particleCount;
        points[config.particleCount + coeffIdx].position.x = config.position_x[coeffIdx];
        points[config.particleCount + coeffIdx].position.y = config.position_y[coeffIdx];
        if (config.markersVisible == 1) {
            points[config.particleCount + coeffIdx].color.r = 2;
            points[config.particleCount + coeffIdx].color.g = 0;
            points[config.particleCount + coeffIdx].color.b = 0;
        } else {
            points[config.particleCount + coeffIdx].color.rgb = vec3(0,0,0);
        }
    } else if (idx == config.particleCount + config.massCount) {
        uint initIdx = config.particleCount + config.massCount;
        points[initIdx].position = config.initPos;
        if (config.markersVisible == 1) {
            points[initIdx].color.r = 3;
            points[initIdx].color.g = config.initR;
            points[initIdx].color.b = atan(config.initVel.y, config.initVel.x);
        } else {
            points[initIdx].color.rgb = vec3(0,0,0);
        }
    }
}